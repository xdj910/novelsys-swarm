#!/bin/bash

# PostToolUse Hook: Automatic Output Fixer
# è‡ªåŠ¨ä¿®å¤å¸¸è§çš„Subagentè¾“å‡ºé—®é¢˜
# åŒ…æ‹¬æˆªæ–­çš„æ–‡ä»¶ã€æ ¼å¼é”™è¯¯ã€ç¼ºå¤±çš„å¿…è¦å…ƒç´ 

# è®¾ç½®é¡¹ç›®æ ¹ç›®å½•
if [[ -z "$CLAUDE_PROJECT_DIR" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    PROJECT_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"
else
    PROJECT_ROOT="$CLAUDE_PROJECT_DIR"
fi

# ç¡®ä¿ç›®å½•å­˜åœ¨
mkdir -p "$PROJECT_ROOT/.claude/logs"
mkdir -p "$PROJECT_ROOT/.claude/fixes"

# ä»stdinè¯»å–Claude Codeæä¾›çš„JSONè¾“å…¥
input=$(cat)

# è§£æè¾“å…¥
tool_name=$(echo "$input" | jq -r '.tool_name // empty' 2>/dev/null)
file_path=$(echo "$input" | jq -r '.tool_input.file_path // .file_path // empty' 2>/dev/null)
content=$(echo "$input" | jq -r '.tool_input.content // .content // empty' 2>/dev/null)

# Fallbackåˆ°grep
[[ -z "$tool_name" ]] && tool_name=$(echo "$input" | grep -o '"tool_name"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 2>/dev/null)
[[ -z "$file_path" ]] && file_path=$(echo "$input" | grep -o '"file_path"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 2>/dev/null)

# å°†Windowsè·¯å¾„è½¬æ¢ä¸ºUnixè·¯å¾„
unix_path=$(echo "$file_path" | sed 's|\\|/|g' | sed 's|^D:|/d|' | sed 's|^C:|/c|')

# åªå¤„ç†Writeæ“ä½œ
if [[ "$tool_name" == "Write" ]] && [[ -f "$unix_path" ]]; then
    
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    fix_log="$PROJECT_ROOT/.claude/logs/auto-fixes.log"
    file_name=$(basename "$unix_path")
    
    # æ ‡è®°æ˜¯å¦ä¿®å¤äº†æ–‡ä»¶
    was_fixed=false
    fix_description=""
    
    # æ£€æµ‹å’Œä¿®å¤å¸¸è§é—®é¢˜
    case "$file_name" in
        
        "content.md")
            # ç« èŠ‚å†…å®¹æ–‡ä»¶çš„å¸¸è§é—®é¢˜
            
            # 1. æ£€æŸ¥æ˜¯å¦è¢«æ„å¤–æˆªæ–­ï¼ˆæ²¡æœ‰ç»“å°¾ï¼‰
            last_line=$(tail -1 "$unix_path" 2>/dev/null)
            if [[ ! "$last_line" =~ \*End.*Chapter.*\* ]] && [[ ! "$last_line" =~ "ç»­" ]] && [[ ! "$last_line" =~ "..." ]]; then
                # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦çœ‹èµ·æ¥ä¸å®Œæ•´
                word_count=$(wc -w < "$unix_path" 2>/dev/null || echo "0")
                
                if [[ "$word_count" -gt 100 ]]; then
                    # æ·»åŠ ä¸´æ—¶ç»“å°¾æ ‡è®°
                    echo "" >> "$unix_path"
                    echo "*[Chapter appears incomplete - pending continuation]*" >> "$unix_path"
                    was_fixed=true
                    fix_description="Added incomplete marker to truncated chapter"
                    echo "[$timestamp] Fixed truncated content: $unix_path" >> "$fix_log"
                fi
            fi
            
            # 2. ä¿®å¤é”™è¯¯çš„ç¼–ç æˆ–ç‰¹æ®Šå­—ç¬¦
            # å°†å¸¸è§çš„ç¼–ç é”™è¯¯å­—ç¬¦æ›¿æ¢
            if grep -q '[Ã¢ÃªÃ®Ã´Ã»]' "$unix_path" 2>/dev/null; then
                sed -i 's/Ã¢â‚¬Å“/"/g; s/Ã¢â‚¬/"/g; s/Ã¢â‚¬â„¢/'"'"'/g' "$unix_path"
                was_fixed=true
                fix_description="$fix_description; Fixed encoding issues"
            fi
            
            # 3. ç¡®ä¿ç« èŠ‚æœ‰æ ‡é¢˜
            first_line=$(head -1 "$unix_path" 2>/dev/null)
            if [[ ! "$first_line" =~ ^#.*Chapter ]]; then
                # ä»è·¯å¾„æå–ç« èŠ‚å·
                chapter_num=$(echo "$unix_path" | grep -o 'ch[0-9]\+' | sed 's/ch0*//')
                if [[ -n "$chapter_num" ]]; then
                    # åœ¨æ–‡ä»¶å¼€å¤´æ’å…¥ç« èŠ‚æ ‡é¢˜
                    temp_file="$unix_path.tmp"
                    echo "# Chapter $chapter_num" > "$temp_file"
                    echo "" >> "$temp_file"
                    cat "$unix_path" >> "$temp_file"
                    mv "$temp_file" "$unix_path"
                    was_fixed=true
                    fix_description="$fix_description; Added missing chapter header"
                fi
            fi
            
            # 4. ä¿®å¤å¤šä½™çš„ç©ºè¡Œï¼ˆè¶…è¿‡3ä¸ªè¿ç»­ç©ºè¡Œï¼‰
            sed -i '/^$/N;/^\n$/N;/^\n\n$/N;/^\n\n\n$/d' "$unix_path" 2>/dev/null
            ;;
            
        "meta.json"|"quality_check.json"|"outline.json")
            # JSONæ–‡ä»¶çš„å¸¸è§é—®é¢˜
            
            # 1. å°è¯•ä¿®å¤JSONè¯­æ³•
            if ! jq empty "$unix_path" 2>/dev/null; then
                # å¤‡ä»½åŸæ–‡ä»¶
                cp "$unix_path" "$unix_path.broken"
                
                # å¸¸è§ä¿®å¤ï¼šç§»é™¤å°¾éšé€—å·
                sed -i 's/,\s*\}/}/g; s/,\s*\]/]/g' "$unix_path"
                
                # ä¿®å¤æœªé—­åˆçš„å¼•å·
                sed -i 's/"\([^"]*\)$/"\1"/' "$unix_path"
                
                # å†æ¬¡æ£€æŸ¥
                if jq empty "$unix_path" 2>/dev/null; then
                    was_fixed=true
                    fix_description="Fixed JSON syntax errors"
                    echo "[$timestamp] Auto-fixed JSON: $unix_path" >> "$fix_log"
                else
                    # å¦‚æœè¿˜æ˜¯æ— æ³•ä¿®å¤ï¼Œæ¢å¤åŸæ–‡ä»¶
                    mv "$unix_path.broken" "$unix_path"
                fi
            fi
            
            # 2. ä¸ºmeta.jsonæ·»åŠ ç¼ºå¤±çš„å¿…è¦å­—æ®µ
            if [[ "$file_name" == "meta.json" ]] && jq empty "$unix_path" 2>/dev/null; then
                # ç¡®ä¿æœ‰åŸºæœ¬å­—æ®µ
                jq '. + {
                    "last_modified": (now | strftime("%Y-%m-%dT%H:%M:%S")),
                    "auto_fixed": true
                } | 
                if .chapter_number == null then .chapter_number = 0 else . end |
                if .word_count == null then .word_count = 0 else . end |
                if .status == null then .status = "draft" else . end' \
                "$unix_path" > "$unix_path.tmp" 2>/dev/null
                
                if [[ $? -eq 0 ]]; then
                    mv "$unix_path.tmp" "$unix_path"
                    was_fixed=true
                    fix_description="$fix_description; Added missing meta fields"
                fi
            fi
            ;;
            
        "bible.yaml"|"bible.yml")
            # Bibleæ–‡ä»¶çš„ä¿®å¤
            
            # ä½¿ç”¨Pythonæ£€æŸ¥å’Œä¿®å¤YAML
            if command -v python3 >/dev/null 2>&1; then
                python3 << EOF
import yaml
import sys

try:
    with open('$unix_path', 'r') as f:
        content = f.read()
    
    # å°è¯•è§£æ
    data = yaml.safe_load(content)
    
    # ç¡®ä¿æœ‰åŸºæœ¬ç»“æ„
    if not isinstance(data, dict):
        data = {}
    
    # æ·»åŠ ç¼ºå¤±çš„å¿…è¦éƒ¨åˆ†
    if 'title' not in data:
        data['title'] = 'Untitled Project'
    if 'characters' not in data:
        data['characters'] = {}
    if 'universe' not in data:
        data['universe'] = {'setting': 'To be defined'}
    if 'metadata' not in data:
        data['metadata'] = {
            'auto_fixed': True,
            'fix_date': '$timestamp'
        }
    
    # å†™å›æ–‡ä»¶
    with open('$unix_path', 'w') as f:
        yaml.dump(data, f, default_flow_style=False, allow_unicode=True)
    
    print("FIXED")
    
except yaml.YAMLError as e:
    # YAMLè§£æé”™è¯¯ï¼Œå°è¯•åŸºæœ¬ä¿®å¤
    lines = content.split('\n')
    fixed_lines = []
    for line in lines:
        # ä¿®å¤ç¼©è¿›é—®é¢˜ï¼ˆç¡®ä¿ä½¿ç”¨ç©ºæ ¼è€Œä¸æ˜¯åˆ¶è¡¨ç¬¦ï¼‰
        line = line.replace('\t', '  ')
        fixed_lines.append(line)
    
    with open('$unix_path', 'w') as f:
        f.write('\n'.join(fixed_lines))
    
    print("BASIC_FIX")
    
except Exception as e:
    print(f"ERROR: {e}")
    sys.exit(1)
EOF
                result=$?
                if [[ $result -eq 0 ]]; then
                    was_fixed=true
                    fix_description="Fixed Bible YAML structure"
                fi
            fi
            ;;
            
        "entity_dictionary.yaml"|"entity_dictionary.yml")
            # å®ä½“å­—å…¸çš„ä¿®å¤
            
            # ç¡®ä¿æ–‡ä»¶ä¸ä¸ºç©º
            if [[ ! -s "$unix_path" ]]; then
                # åˆ›å»ºåŸºæœ¬ç»“æ„
                cat > "$unix_path" << 'EOF'
# Entity Dictionary - Auto-generated template
entities:
  characters: []
  locations: []
  items: []
  
metadata:
  created: AUTO_GENERATED
  last_updated: AUTO_GENERATED
EOF
                # æ›´æ–°æ—¶é—´æˆ³
                sed -i "s/AUTO_GENERATED/$timestamp/g" "$unix_path"
                was_fixed=true
                fix_description="Created entity dictionary template"
            fi
            ;;
    esac
    
    # é€šç”¨ä¿®å¤ï¼šæ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«æˆªæ–­ï¼ˆæ–‡ä»¶æœ«å°¾æ˜¯å¦ä¸æ­£å¸¸ï¼‰
    if [[ -f "$unix_path" ]]; then
        # è·å–æ–‡ä»¶æœ€åå‡ ä¸ªå­—ç¬¦
        last_chars=$(tail -c 20 "$unix_path" 2>/dev/null)
        
        # æ£€æŸ¥æ˜¯å¦ä»¥ä¸å®Œæ•´çš„å¥å­ç»“å°¾ï¼ˆæ²¡æœ‰å¥å·ã€å¼•å·ç­‰ï¼‰
        if [[ "$last_chars" =~ [a-zA-Z0-9]$ ]] && [[ ! "$last_chars" =~ [\.!?\"\'}\]]$ ]]; then
            # å¯èƒ½è¢«æˆªæ–­äº†
            echo "" >> "$unix_path"
            echo "[FILE MAY BE TRUNCATED - PLEASE VERIFY]" >> "$unix_path"
            
            # è®°å½•åˆ°ä¿®å¤æ—¥å¿—
            echo "[$timestamp] Warning: Possible truncation detected in $unix_path" >> "$fix_log"
            
            # åˆ›å»ºæˆªæ–­è­¦å‘Šæ–‡ä»¶
            truncation_warning="$PROJECT_ROOT/.claude/fixes/truncation_$(date +%Y%m%d_%H%M%S).txt"
            cat > "$truncation_warning" << EOF
Truncation Warning
==================
File: $unix_path
Time: $timestamp
Last 100 characters:
$(tail -c 100 "$unix_path")

This file appears to be truncated. Please verify and regenerate if necessary.
EOF
        fi
    fi
    
    # è®°å½•ä¿®å¤ç»“æœ
    if [[ "$was_fixed" == "true" ]]; then
        echo "[$timestamp] âœ“ Auto-fixed: $unix_path" >> "$fix_log"
        echo "  Fixes: $fix_description" >> "$fix_log"
        
        # åˆ›å»ºä¿®å¤æŠ¥å‘Š
        fix_report="$PROJECT_ROOT/.claude/fixes/fix_$(date +%Y%m%d_%H%M%S).txt"
        cat > "$fix_report" << EOF
Auto-Fix Report
===============
Time: $timestamp
File: $unix_path
Fixes Applied: $fix_description

The file has been automatically fixed. Please review the changes.
Original file backed up as: ${unix_path}.broken (if applicable)
EOF
        
        echo "ğŸ”§ Auto-fixed issues in $file_name"
    fi
fi

# æˆåŠŸé€€å‡º
exit 0